---
timezone: Asia/Shanghai
---

> 请在上边的 timezone 添加你的当地时区，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区
> 时区请参考以下列表，请移除 # 以后的内容

timezone: Pacific/Honolulu # 夏威夷-阿留申标准时间 (UTC-10)

timezone: America/Anchorage # 阿拉斯加夏令时间 (UTC-8)

timezone: America/Los_Angeles # 太平洋夏令时间 (UTC-7)

timezone: America/Denver # 山地夏令时间 (UTC-6)

timezone: America/Chicago # 中部夏令时间 (UTC-5)

timezone: America/New_York # 东部夏令时间 (UTC-4)

timezone: America/Halifax # 大西洋夏令时间 (UTC-3)

timezone: America/St_Johns # 纽芬兰夏令时间 (UTC-2:30)

timezone: Asia/Dubai # 海湾标准时间 (UTC+4)

timezone: Asia/Kolkata # 印度标准时间 (UTC+5:30)

timezone: Asia/Dhaka # 孟加拉国标准时间 (UTC+6)

timezone: Asia/Bangkok # 中南半岛时间 (UTC+7)

timezone: Asia/Shanghai # 中国标准时间 (UTC+8)

timezone: Asia/Tokyo # 日本标准时间 (UTC+9)

timezone: Australia/Sydney # 澳大利亚东部标准时间 (UTC+10)

---

# {whw2025}

1. 我是一个web3新人，之前没有接触过任何编程，但对此非常感兴趣，很有幸碰到这样的学习机会；希望可以通过学习提升自己。

2. 确实由于完全没有相关基础，估计会有困难，但会尽力完成。
   
## Notes

<!-- Content_START -->

### 2024.09.23

第一节：hello web3

1、// SPDX-License-Identifier: MIT
说明代码的软件许可；不写许可，编译时会出现警告（warning）；Solidity 注释以“//”开头；即表示新开启一个小项；

2、pragma solidity ^0.8.21;
该行表示Solidity使用的版本；Solidity 语句以分号（;）结尾

3、contract HelloWeb3 {
    string public _string = "Hello Web3!";
}
contract后面表示为合约名；{}中表示为合约内容；_string定义的内容为Hello Web3!

问题1：}是否必须另起一行？


第二节：值类型

4、变量类型包括：值类型(Value Type)、引用类型(Reference Type)、映射类型(Mapping Type)；

5、值类型包括：布尔型、整型、地址类型、定长字节数组、枚举 enum

1）布尔型是二值变量，取值为 true 或 false

布尔值的运算符包括：
! （逻辑非）
&& （逻辑与，"and"）
|| （逻辑或，"or"）
== （等于）
!= （不等于）

问题2：
_bool && _bool1 为 false；_bool || _bool1 为 true；那么结合前面的陈述，这里的_bool 是以“true”取值吗？是否表示“true && false”为false；“true || false”为true；

&& 和 || 运算符遵循短路规则：当逻辑与（&&）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件；

问题3：
当逻辑与（&&）的第一个条件为true时，当逻辑或（||）的第一个条件为false时，该如何判断第二个条件？

GPT答：
对于逻辑与（&&）：
• 当第一个条件为 true 时，仍需判断第二个条件。如果第二个条件为 true，则整个表达式为 true；如果第二个条件为 false，则整个表达式为 false。
• 对于逻辑或（||）：
• 当第一个条件为 false 时，仍需判断第二个条件。如果第二个条件为 true，则整个表达式为 true；如果第二个条件为 false，则整个表达式为 false。

根据gpt的解释，则可以理解问题1“_bool && _bool1 为 false；_bool || _bool1 为 true；”_bool 取值为true，所以逻辑&&仍需判断第二个条件，而_bool1 为 false，所以_bool && _bool1 为 false；但在逻辑 || 中，因为第一个_bool 为true，所以不再判断第二个变量，所以_bool || _bool1 为 true。

2）整型是 Solidity 中的整数，常用包括int（负整数）、uint（正整数）、uint256（256位正整数）

常用的整型运算符包括：
比较运算符（返回布尔值）： <=， <，==， !=， >=， >
算数运算符： +， -， *， /， %（取余），**（幂）

问题4：
int是负整数的表示吗？为什么说是整数，又包括负数；uint是正整数的表示符号吗？
/ 跟%取余有什么不同？
**幂是什么意思，怎么取值？

GPT答：

int 是有符号整数，可以表示正数、负数和零，因此包括负数。它的范围从负的最大值到正的最大值；uint 是无符号整数，仅表示正整数和零，不能表示负数。它的范围从 0 到正的最大值。因此，int 包括负数，而 uint 只表示正整数。

/：表示除法运算，返回商（不包括余数）。表示取余运算，返回除法运算的余数。

幂运算符，用于表示指数运算。它返回一个数的某次幂。例如：2**3 表示 2 的 3 次幂，即 2 × 2 × 2 = 8。

3）地址类型(address)：包括普通地址（address）和payable address；
普通地址（address）: 存储一个 20 字节的值（以太坊地址的大小）。
payable address: 比普通地址多了 transfer 和 send 两个成员方法，用于接收转账。

4）定长字节数组：字节数组分为定长和不定长两种；

定长字节数组: 属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 bytes1, bytes8, bytes32 等类型。定长字节数组最多存储 32 bytes 数据，即bytes32。

不定长字节数组: 属于引用类型，数组长度在声明之后可以改变，包括 bytes 等。

基础知识：
0x 是表示十六进制数的前缀;
字节（Byte）：一个字节是由 8 位（bit） 组成的。也就是说，1 字节 = 8 位。
位（Bit）：是计算机中最小的数据单位，可以是 0 或 1。
所以，32个字节 意味着 256位（32字节 × 8 位/字节 = 256 位）。
在十六进制中，每两个数字表示一个字节，0x4D 是一个字节，占 8 位（01001101），它可以存储一个字符，字符 'M' 的 ASCII 编码是 77（十进制），换算为 4D（十六进制）

5）枚举（enum）：是 Solidity 中用户定义的数据类型；它主要用于为 uint 分配名称，使程序易于阅读和维护。

### 

<!-- Content_END -->
